# -*- coding: utf-8 -*-
"""Problem_Sheet_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bBYOdem_R9AMPNSmAZOJwemTmiQ8R0wg
"""

#Define the Function
from sympy import *
x = Symbol('x')

def f(c):
  f =  3*x + sin(x) - pow(math.e,x)
  fs = N(f.subs(x,c))
  return fs

# Bisection Method

def Bisection():
  global a,b,mid,count
  if ( (f(a) * f(b)) < 0 ):
     mid = (a + b)/2
     if (f(mid) == 0):
      d = 1
      print(f"{mid} is the root")
     else:
      print(f"{count}\t{a}\t{b}         {f(a)}         {f(b)}         {mid}          {f(mid)}")
      mid = round(mid,4)
      if (f(mid) * f(a)) < 0:
       b = mid
      else:
       a = mid

# Regula Falsi Method

def Regula_Falsi():
  global a,b,count,mid
  if ( (f(a) * f(b)) < 0 ):
     h = (abs(f(a))*(b-a)) /(abs(f(a)) + abs(f(b)))
     mid = a + h
     if ( f(mid) == 0):
      d = 1
      print(f"{mid} is the root")
     else:
      print(f"{count}     {a}         {b}          {f(a)}            {f(b)}        {mid}           {f(mid)}")
      mid = round(mid,4)
      if (f(mid) * f(a)) < 0:
       b = mid
      else:
       a = mid

# Newton Rapshon Method

def f1(c):
  f =  3*x + sin(x) - pow(math.e,x)
  derv = Derivative(f)
  d1 = derv.doit()
  d2 = N(d1.subs(x,c))
  return d2

def Newton_Rapshon(c):
  global x_1,x_2,count
  x_1 = c
  x_2 = x_1 - (f(x_1)/f1(x_1))
  while(True):
    if abs(x_1 - x_2) <= 0.0001 :
      print(f'{x_2} is the root')
      break
    else:
      count = count + 1
      print(f"{count}         {x_1}            {x_2}  ")
      x_1 = x_2
      x_2 = x_1 - (f(x_1)/f1(x_1))

from sympy import *
x = Symbol('x')

def g(c):
  p = 1 + tan(x)
  p1 = N(p.subs(x,c))
  return p1

def Fixed_Point_Iteration(c):
  global count
  x_1 = c
  while(True):
    x_2 = g(x_1)
    if abs(x_1 - x_2) <= 0.0001:
      print(f'{x_2} is the root')
      break
    else:
      x_1 = x_2
      count = count + 1
      print(f'{count}          {x_1}')

while(True):
  print("\n 1. Bisection Method \n 2. Newton Rapshon \n 3. Regula FalsiMethod \n 4. Fixed Point Iteration Method")
  ch = int(input("\n Enter your Choice: "))

  old_mid = 0
  mid = 0
  d = 0

  a = 1
  b = 2

  match ch:

    case 1:
      count = 0
      if f(a) == 0:
        print(f'{a} is the root')
      elif f(b) == 0:
        print(f'{b} is the root')
      else:
        print("\n Iteration           a             b              f(a)            f(b)            mid             f(mid)")
      while(True):
        Bisection()
        if d == 1 :
         break
        if abs(mid - old_mid) >= 0.0001:
          old_mid = mid
          count = count + 1
        else:
          print(f'\n The root is {mid}')
          break

    case 2:
      count = 0
      if f(a) == 0:
        print(f'{a} is the root')
      elif f(b) == 0:
        print(f'{b} is the root')
      else:
        print(f'Iteration         x_n         x_n+1')
        x_1 = a - (f(a)/f1(a))
        print(f'{count}           {a}          {x_1}')
        Newton_Rapshon(x_1)


    case 3:
      count = 0
      if f(a) == 0:
        print(f'{a} is the root')
      elif f(b) == 0:
        print(f'{b} is the root')
      else:
        print("Iteration           a             b              f(a)            f(b)            mid             f(mid)")
      while(True):
        Regula_Falsi()
        if d == 1 :
         break
        if abs(mid - old_mid) >= 0.0001:
          old_mid = mid
          count = count + 1
        else:
          print(f'\n The root is {mid}')
          break

    case 4:
      count = 0
      if f(a) == 0:
        print(f'{a} is the root')
      elif f(b) == 0:
        print(f'{b} is the root')
      else:
        print("Iteration           x_n+1")
        x_1 = g(b)
        print(f'{count}           {x_1}')
        Fixed_Point_Iteration(x_1)

  ch1 = input("\n Do you want to Continue (yes/no) ? ")
  if ch1 == "yes":
    continue
  else:
    break

# Plot the Graph
import matplotlib.pyplot as plt
import numpy as np
import math

x = np.linspace(0,0.5, 100)
#plt.plot(x, x**2,'r*',label='y=x^2')
plt.plot(x, np.exp((x**2)-1)+10*np.sin(2*x)-5,'g--',label='y=e^((x^2)-1)+10sin2x-5')
#plt.plot(x, np.sin(x),'y-',label = 'y=sin x')
plt.xlabel('X - axis')
plt.ylabel('Y- axis')
plt.title('Interval Checking')
#plt.grid()
plt.legend(loc = 1)
plt.xlim(-2,2)
plt.ylim(-2,2)
plt.axvline(x=0, c='k')
plt.axhline(y=0, c='k')
plt.show()