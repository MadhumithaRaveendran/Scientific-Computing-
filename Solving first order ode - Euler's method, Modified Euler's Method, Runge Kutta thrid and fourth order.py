# -*- coding: utf-8 -*-
"""problem_Sheet_7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13KH1dFjMrc087ZL5qti2hsKBrjNFNnPa
"""

# Euler's Method

from sympy import *
x,y = symbols('x y')

x_0 = 0
y_0 = 1
x = 1
n = 10
h = (x - x_0)/n

print(f'x      y      f(x,y)      new_y')
while True:
  f = x + y
  f_0 = round(f.subs([(x,x_0),(y,y_0)]),4)
  new_y = round((y_0 + (h * f_0)),4)
  if x == x_0:
    break
  print(f'{x_0}       {y_0}       {f_0}       {new_y}')
  x_0 = round((x_0 + h),4)
  y_0 = round(new_y,4)

print(f'y({x}) = {y_0}')

# Modified Euler Method

from sympy import *
x,y = symbols('x y')

x_0 = 4
y_0 = 1
x = 4.4
n = 4
h = round(((x-x_0)/n),2)

print(f'x          y           f(x,y)           mean_slope              new_y')
for i in range(n):
  f = x + y
  f_0 = round((f.subs([(x,x_0),(y,y_0)])),4)
  new_y = round((y_0 + (h * f_0)),4)
  print(f'{x_0}          {y_0}             {f_0}            -           {new_y}')
  x_0 = round((x_0 + h),4)
  y_old = y_0
  while True:
    y_0 = new_y
    f_1 = round((f.subs([(x,x_0),(y,y_0)])),4)
    mean = round(((f_0 + f_1)/2),4)
    new_y = round((y_old + (h * mean)),4)
    print(f'{x_0}           {y_0}           {f_1}          {mean}           {new_y}')
    if abs(y_0 - new_y) <= 0.0001:
      break
  print(f'y({x_0}) = {new_y}')

#Runge Kutta Third Order

from sympy import *
x,y = symbols('x y')

x_0 = -2
y_0 = -1
x = 1
n = 3
h = (x - x_0)/n

while True :
  f = cos(x+y) * ((x**2) + (2*y))
  k1 = h * (f.subs([(x,x_0),(y,y_0)]))
  k2 = h * (f.subs([(x,(x_0 + (h/2))),(y,(y_0 + (k1/2)))]))
  k_1 = h * (f.subs([(x,(x_0 + h)),(y,(y_0 + k1))]))
  k3 = h * (f.subs([(x,(x_0 + h)),(y, (y_0 + k_1))]))
  k = (1/6) * (k1 + (4 * k2) + k3)
  y_1 = round(y_0 + k,4)
  print(f'y({x_0 + h}) = {y_1}')
  x_0 = x_0 + h
  if x == x_0:
    break
  y_0 = y_1

# Runge Kutta Fourth Order

from sympy import *
x,y = symbols('x y')

x_0 = -2
y_0 = -0.5
x = 2
f = cos(x+y) + (x**2) - (x*y)
n = 4
h = (x - x_0)/n

for i in range(1,n+1):
  k1 = h * (f.subs([(x,x_0),(y,y_0)]))
  k2 = h * (f.subs([(x,(x_0 + (h/2))),(y,(y_0 + (k1/2)))]))
  k3 = h * (f.subs([(x,(x_0 + (h/2))),(y,(y_0 + (k2/2)))]))
  k4 = h * (f.subs([(x,(x_0 + h)),(y, (y_0 + k3))]))
  k = (1/6) * (k1 + (2 * k2) + (2 * k3) + k4)
  y_1 = round((y_0 + k),4)
  print(f'\ny({x_0 + h}) = {y_1}')
  x_0 = x_0 + h
  if x_0 == x:
    break
  y_0 = y_1