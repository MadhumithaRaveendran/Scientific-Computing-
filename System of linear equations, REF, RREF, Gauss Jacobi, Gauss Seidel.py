# -*- coding: utf-8 -*-
"""Problem_Sheet_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XxFlYR8TmLM-oHLvkDhkh9r9qjr0q9e2
"""

#1
import numpy as np

A = np.array([[2,-3,4,-4],[7,1,-8,9],[2,-8,1,-1]])
b = np.array([[0,0,0]])

arr1 = np.concatenate([A,b.T],axis = 1)
print(arr1)

import numpy as np
mat=[]
n=int(input())
m=int(input())
for i in range(n):
  mat1=[]
  for k in range(m):
    mat1.append(int(input(f"mat[{i}][{k}]")))
  mat.append(mat1)
print('Matrix=\n', np.array(mat))

#2
import numpy as np

A = np.array([[1,2,3],[0,0,1],[1,0,0],[0,0,0]])

empty = []
non_empty = []
pivot = []
p1 = []

# To check the number of zero entries in a row
def checkZeroRow(list1):
  count = 0
  for i in range(A.shape[1]):
    if list1[i] == 0:
      count = count + 1
  if count == A.shape[1]:
    return True
  else:
    return False

# To split the zero rows (index) and non zero rows
def splitRows(A):
   for i in range(A.shape[0]):
     if checkZeroRow(A[i,:]):
        empty.append(i)
     else:
        non_empty.append(A[i,:])

   arr_nonempty = np.array(non_empty)
   return empty,arr_nonempty

# To check the first non zero entry in a row is 1, if it is not 1, then first condition fails
def leadingOneCheck(list1):
  for j in range(len(list1)):
          if list1[j] == 0:
            continue
          elif list1[j] == 1:
              p1.append(j)
              return True
              #break
          else:
            return False

# Condition 1 : The first non zero entry in a row must be 1
def condition_1(B,C):
  if len(B) == A.shape[0]:
    return True
  else:
    for i in range(C.shape[0]):
        if leadingOneCheck(C[i,:]):
          pivot.append(i)

    if len(pivot) == C.shape[0]:
      return True
    else:
      return False

# Condition 2 : To check whether the zero rows are the bottom
def condition_2(B):
  B.reverse()
  for i in range(len(B)):
    if B[i] == A.shape[0] - 1 - i:
      continue
    else:
      return False
  return True

# Condition 3 : The succedding pivot element must be at the right preceeding pivot element
def condition_3(pivot):
  if len(set(p1)) == len(p1):
    for i in range(len(pivot)-1):
      if pivot[i] < pivot[i+1]:
        continue
      else:
        return False
    return True
  else:
   return False

# Condition 4 : To check the elements above the pivot element must be zero
def condition_4(C):
  for i in range(C.shape[0]-1,0,-1):
    for j in range(i): #C.shape[0]-1
      m = pivot[i]
      if C[j][m] != 0:
        return False
  return True

# Main
B,C = splitRows(A)
con_list = []
con_list.append(condition_1(B,C))
con_list.append(condition_2(B))
con_list.append(condition_3(pivot))

if all(con_list):  # all() function returns true if all the entries in the list is true otherwise it returns false
  if condition_4(C):
    print(A)
    print('The given matrix is in REF and RREF')
  else:
    print(A)
    print('The given matrix in REF')
else:
  print(A)
  print('The given matrix is not in REF')

#3 REF

import numpy as np

A = np.array([[1,1,1,8],[-1,-2,3,1],[3,-7,4,10]])
#A = np.array([[2,0,4,-1],[2,3,4,0],[1,1,2,4]])

#To rewrite the matrix first entry to one if it is not equal to one (i.e) A[0][0] = 1
def leadingOne(A):
    t = A[0][0]
    for i  in range(A.shape[1]):
      A[0][i] = A[0][i]/t
    return A

def fixRow(A):
  if A[0][0] != 0:
    A = leadingOne(A)
  else:
     # all the entris below leading one must be zero
     for i in range(1,A.shape[0]):
        if A[i][0] != 0:
          A[[0,i]] = A[[i,0]]  # swapping 0 th row and i th row
          A = leadingOne(A)
          break

  for i in range(1,A.shape[0]):
    if A[i][0] != 0:              # if A[1][0] != 0 then R1 -> R1 - A[1][0] * R0
      arr = np.array(A[0,:])
      arr = arr * A[i][0]
      arr1 = np.array(A[i,:])
      A[i,:] = np.subtract(arr1,arr)
  return A

# To check total number of zero entries in the column
def checkZero(list2):
  k = len(list2)
  count = 0
  for i in range(k):
    if list2[i] == 0:
      count = count + 1
  if(count == k):
    return True
  else:
    return False

# To check first non zero column
def multipleCheckZero(A):
  count = 0
  for i in range(A.shape[1]):
    if checkZero(A[:,i]):
        count = count + 1
    else:
      break
  return count

def repeat(A):

    m1 = multipleCheckZero(A)

    #if all the columns are zero then it should return that matrix (i.e zero matrix)
    if m1 == A.shape[1]:
      return A
    else:
    #else the number zero columns should be removed
      for j in range(m1):
        A = np.delete(A,0,axis=1)
      A = fixRow(A)
      if m1 > 0:
        for k in range(m1):
          arr = np.zeros((A.shape[0],1))
          A = np.concatenate([arr,A],axis=1)
      return A

# First row of the A matrix will be the first row of REF appending it to REF matrix and deleting that row from A matrix
def delRow(A):
  temp1 = A[0,:]
  A = np.delete(A,0,axis=0)
  ref.append(temp1)
  return A

# main
ref = []
m = A.shape[0]
for i in range(m):
  A = repeat(A)
  A = delRow(A)
ref = np.array(ref)

print('\nThe REF is \n')
print(ref)

#RREF

ref_row = ref.shape[0]
ref_col = ref.shape[1]

non_empty  = []
empty = []

#To check the total number zero entries in the row
def checkZeroRow(list1):
  count = 0
  for i in range(ref_col):
    if list1[i] == 0:
      count = count + 1
  if count == ref_col:
    return True
  else:
    return False

# Split the zero rows and non-zero rows
def NonZeroMatrix(ref):
  for i in range(ref_row):
     if checkZeroRow(ref[i,:]):
        empty.append(ref[i,:])
     else:
        non_empty.append(ref[i,:])
  arr_empty = np.array(empty)
  arr_non_empty = np.array(non_empty)
  return  arr_empty, arr_non_empty

# The elements present above and below the pivot element must be zero
def reductionToRREF(C):
  for i in range(C.shape[0]-1,0,-1):
    for j in range(i):
      m = p[i]
      if C[j][m] != 0:
        arr = np.array(C[i,:])
        arr = arr * C[j][m]
        arr1 = np.array(C[j,:])
        C[j,:] = np.subtract(arr1,arr)
  return C

# main
B,C = NonZeroMatrix(ref)
p = []

# To find pivot position
for i in range(C.shape[0]):
 for j in range(C.shape[1]):
   if C[i][j] == 1:
      p.append(j)
      break

# If there is no pivot elements then the matrix is Zero matrix, so return the Zero matrix
if len(p) == 0:
  rref = B
else:
# Reduce to RREF
  C = reductionToRREF(C)
  if C.shape[0] == ref.shape[0]:  # if both REF and RREF row size are equal return RREF
     rref = C
  else:
    rref = np.concatenate([C,B],axis=0) # else return C and append B (empty matrix) at the bottom

print(rref)
print(tuple(p)) # prints the pivot position (i.e column index)
print("\n The rank of the matrix is ",len(p))

#4
import numpy as np

row = int(input('Enter the number of rows: '))
col = int(input('Enter the number of columns: '))

print('Enter ',row*col,' elements for Coefficient matrix: ')
mat = []
for i in range(row):
  r = []
  for j in range(col):
    r.append(int(input()))
  mat.append(r)

arr = np.array(mat)
print('The Coefficient Matrix \n', arr)

print('Enter the',row,' elements for Constant Matrix:')
mat1 = []
for i in range(row):
   r1 = []
   for j in range(1):
    r1.append(int(input()))
   mat1.append(r1)

arr1 = np.array(mat1)
print('The Constant Matrix \n',arr1)

try:
  x = np.linalg.solve(arr,arr1)
  print('The Solution is :',x)
except:
  arr2 = np.concatenate([arr,arr1],axis = 1)
  print(arr2)
  if ( np.linalg.matrix_rank(arr) == np.linalg.matrix_rank(arr2)):
    print('Infinite Solution')
  else:
    print('No Solution')
    print('The rank of A: ',np.linalg.matrix_rank(arr))
    print('The rank of A: ',np.linalg.matrix_rank(arr2))

#5
def Isdm(n,A):
  for i in range(n):
    sum = 0
    for j in range(n):
      sum = sum + abs(A[i][j])
    sum = sum - abs(A[i][i])
    if abs(A[i][i]) <= sum:
      return False
  return True

import numpy as np

n = int(input('Enter the order of the matrix: '))
mat = []

m = n * n
print('Enter ',m,' elements')
for i in range(n):
  r = []
  for j in range(n):
    r.append(int(input()))
  mat.append(r)

mat1 = np.array(mat)
if(Isdm(n,mat1)):
  print('Strictly Diagonally Dominant')
else:
  print('Not Strictly Diagonally Dominant')

#6, 7
import numpy as np

''' n = int(input('Enter the order of the Matrix: '))
mat = []

print('Enter the Coefficient Matrix: ')
print('Enter ',n*n,' elements: ')
for i  in range(n):
  r = []
  for j in range(n):
    r.append(float(input()))
  mat.append(r)

mat = np.array(mat)

print('Enter the constant matrix: ')
con = []
for k in range(n):
  c = []
  for k1 in range(1):
    c.append(float(input()))
  con.append(c)

con = np.array(con)

err = float(input('Enter the error term: '))

print('Enter Intial Vector: ')
old = []
for i in range(n):
  r1 = []
  for j in range(1):
    r1.append(float(input()))
  old.append(r1)

old = np.array(old) '''

mat = np.array([[4,1,1],[1,5,2],[1,2,3]])
con = np.array([[2],[-6],[-4]])
err = 0.0001
old = np.array([[0],[0],[0]])
n = 3

arr = np.concatenate([mat,con],axis = 1)

# checking whether it is strictly diagonally dominant (i.e) abs(A[0][0]) > abs(A[0][1]) + abs(A[0][2])
def Isdm(n,A):
  for i in range(n):
    sum = 0
    for j in range(n):
      sum = sum + abs(A[i][j])
    sum = sum - abs(A[i][i])
    if abs(A[i][i]) <= sum:
      return False
  return True

# To get the index of the absolute maximum value in the row
max_index = []
def diagonalIndex(mat):
  for i in range(mat.shape[0]):
    t = max(mat[i,:],key = abs)
    list_1 = list(mat[i,:])
    max_index.append(list_1.index(t,0))

  if len(max_index) == len(set(max_index)):  # checks whether maximum element are in distinct index
    return True
  else:
    return False

# Swapping is performed with max_index list
def swaping(max_index,arr):
  A = np.zeros((arr.shape[0],arr.shape[1]))
  for i in range(len(max_index)):
    A[max_index[i],:] = arr[i,:]
  return A

def Iteration1(arr,vector):
  A = np.delete(arr,arr.shape[1]-1,axis = 1) # Coefficient Matrix
  C = arr[:,arr.shape[1]-1]
  C = C.reshape(n,1)  # Constant Matrix
  diagonal = []
  for i in range(A.shape[0]):
    diagonal.append(A[i][i] * vector[i][0])
  diagonal = np.array(diagonal)
  dia_mat = diagonal.reshape(n,1)

  list_d = np.zeros((n,1))
  dummy = np.subtract(C,A.dot(vector)) + dia_mat
  for j in range(dummy.shape[0]):
    list_d[j][0] = dummy[j][0]*(1/A[j][j])
  return list_d

def Jacobi(arr,old):
  while True :
    print(old.reshape(1,n))
    new = Iteration1(arr,old)
    sub_arr = np.subtract(new,old)
    for i in range(sub_arr.shape[0]):
      if abs(sub_arr[i][0]) > err:
        old = new
        break
      else:
        continue
    if i == sub_arr.shape[0]-1:
      print('The Solution: ', new.reshape(1,n))
      break


def Iteration2(arr,old):
   A = np.delete(arr,arr.shape[1]-1,axis = 1) # Coefficient Matrix
   C = arr[:,arr.shape[1]-1]
   C = C.reshape(n,1)  # Constant Matrix
   for i in range(A.shape[0]):
    old_1 = []
    for j in range(old.shape[0]):
     old_1.append(old[j][0])
    arr1 = A[i,:].reshape(1,n)
    arr2 = C[i][0].reshape(1,1)
    arr3 = np.subtract(arr2,arr1.dot(old))
    arr4 = (A[i][i] * old[i][0]).reshape(1,1)
    temp = (arr3 + arr4) * (1/A[i][i])
    old_1[i] = temp[0][0]
    old_1 = np.array(old_1)
    old_1 = old_1.reshape(n,1)
    old = old_1
   return old

def Seidel(arr,old):
   while True:
    print(old.reshape(1,n))
    temp = Iteration2(arr,old)
    sub_arr = np.subtract(temp,old)
    for i in range(sub_arr.shape[0]):
      if abs(sub_arr[i][0]) > err:
        old = temp
        break
      else:
        continue
    if i == sub_arr.shape[0]-1:
      print('The Solution: ', old.reshape(1,n))
      break

# if the given matrix is diagonally dominant
if(Isdm(n,mat)):
   Jacobi(arr,old)
else:
     # if the given matrix is not diagonally dominant
    if diagonalIndex(mat):
        mat1 = swaping(max_index,arr) # swapping Rows
        Jacobi(mat1,old)
    else:
      print('For Any interchange the matrix is not diagonally dominant')